#!/usr/bin/env ruby
#
# DITA for Small Teams 
#
# Post-receive server-side git hook
# to update DFST Link Management database
# with any changes as a result of updates
# to the repository.
#--------------------------------------------
#
# In the context of the docker containers the network details
# are invariant.

# For use in container, value should be "linkmgr".
$BaseXHost="linkmgr"

require_relative "./BaseXClient"

# The grit package appears to be a nice
# git client but don't really need it
# for what we're doing here.
#require 'rubygems'
#require 'grit'

class Updater
  def initialize(from, to, branch, repoName)
     @from = from
     @to = to
     @branch = branch
     @repoName = repoName
     @basex = BaseXClient::Session.new($BaseXHost, 1984, "admin", "admin")
  end
  
  def cleanBranchName(branch)
    # Trim off leading ref/heads:
    branch.sub!("refs/heads/", "")
    branch.tr('/.', '~_')
  end
  
  def getDatabaseNameForBranch(branch)
      dbName="dfst^#{@repoName}^#{cleanBranchName(branch)}"
  end
  
  def dbExists(dbname)
      result = @basex.execute("open #{dbname}")
      return true
      
      rescue
        return false
  end
  
  def loadChanges
     dbname = getDatabaseNameForBranch(@branch)

     changes = `git diff #{@from} #{@to} --name-only --diff-filter=AM`
     
     changes.split(/\n/).each do |path|
        puts "Added or modified file: \"#{path}\""
        if not path =~ /.+\.(xml|dita|ditamap|ditaval)$/
           puts "Skipping non-XML file"
           next
        end
        bytes = `git cat-file blob #{@to}:#{path}` 
        # puts "bytes=/#{bytes}/"
        #@basex.add(path, "#{bytes}")
        @basex.execute("check #{dbname}")
        addOrReplaceFile(dbname, path, bytes)
     end
     
     # Do deletions:
     changes = `git diff #{@from} #{@to} --name-only --diff-filter=D`

     changes.split(/\n/).each do |path|
        puts "Deleted file: \"#{path}\""
        @basex.execute("delete \"#{path}\"")
        # puts "#{@basex.info()}"
     end
  end
  
  def addOrReplaceFile(dbname, path, bytes)
      #puts "addOrReplaceFile(): path=\"#{path}\""
      #puts "                    dbname=\"#{dbname}\""
      fileUri = @basex.execute("xquery for $doc in db:open(\"#{dbname}\", \"#{path}\") return document-uri($doc)")
      #puts "   query status=#{@basex.info()}"
      #puts "fileUri=#{fileUri}"
      if fileUri != ""
         puts "  File exists in database, deleting..."
         @basex.execute("delete \"#{path}\"")
         # puts "  #{@basex.info()}"
      end
      puts "   Adding file \"#{path}\" to database #{dbname}..."
      cmd = "add to \"#{path}\" #{bytes}"
      @basex.execute(cmd)      
      puts "   #{@basex.info()}"
  end
  
  def recordGitStateDetails
     puts "Recording git state details" 
     metaDbName = getDatabaseNameForBranch(@branch)
     xmlData=<<-EOS
<?xml version="1.0" encoding="UTF-8"?>
<dfst_metadata>
  <gitstate>
    <repodir>{unset}</repodir>
    <repo>#{@repoName}</repo>
    <branch>#{@branch}</branch>
    <commit>#{@to}</commit>
  </gitstate>
</dfst_metadata>
     EOS
     @basex.execute("check #{metaDbName}")
     addOrReplaceFile(metaDbName, ".dfst/metadata.xml", xmlData)
  end
  
  def update()
     puts "Updating using #{@from}, #{@to}, #{@branch}"
     loadChanges
     recordGitStateDetails
  end
end

def getRepoName
  parts = `pwd`.split('/')
  repoName = parts[parts.length - 3]
end

puts "Running post-receive..."




STDIN.each do |line|
   # puts "line=/#{line.chomp}/"
   from, to, branch, = line.chomp.split(/\s+/)

   #puts "from=#{from}"
   #puts "to=#{to}"
   #puts "branch=#{branch}"
   updater = Updater.new(from, to, branch, getRepoName())
   updater.update()

end


puts "Post-receive done."