#!/usr/bin/env ruby
#
# DITA for Small Teams 
#
# Post-receive server-side git hook
# to update DFST Link Management database
# with any changes as a result of updates
# to the repository.
#--------------------------------------------
#
# In the context of the docker containers the network details
# are invariant.

# For use in container, value should be "linkmgr".
$BaseXHost="linkmgr"

require_relative "./BaseXClient"

# The grit package appears to be a nice
# git client but don't really need it
# for what we're doing here.
#require 'rubygems'
#require 'grit'

class Updater
  def initialize(from, to, branch, repoName)
     @from = from
     @to = to
     @branch = branch
     @repoName = repoName
     @basex = BaseXClient::Session.new($BaseXHost, 1984, "admin", "admin")
  end
  
  def cleanBranchName(branch)
    branch.tr('/.', '~_')
  end
  
  def getDatabaseNameForBranch(branch)
       
       dbName="dfst^#{@repoName}^#{cleanBranchName(branch)}"

  end
  
  def getMetadataDatabaseNameForBranch(branch)
      
      metadataDbName="_dfst^metadata^#{@repoName}^#{cleanBranchName(branch)}"
  end
  
  def ensureDatabase(dbname)
  
     # Correct characters that can't be used
     # in database names:
     # The "check" command creates the database if it doesn't exist.
     puts "ensureDatabase(): Checking database \"#{dbname}\"..."
     @basex.execute("check #{dbname}")
     puts "BaseXResult: #{@basex.info}"
  end

  def update()
     puts "Updating using #{@from}, #{@to}, #{@branch}"
     dbname = getDatabaseNameForBranch(@branch)
     metaDbName = getMetadataDatabaseNameForBranch(@branch)
     ensureDatabase(metaDbName)
     ensureDatabase(dbname)
     # git show --pretty="format:" --name-status 
     # Eliots-MBP:temp ekimber$ git show --pretty="format:" --name-status 
     # A       test-newname.xml
     # D       test.xml
     
     # Do adds and modifications:
     # Each line will be the path to a file
     changes = `git diff #{@from} #{@to} --name-only --diff-filter=AM`
     
     changes.split(/\n/).each do |path|
        puts "Added or modified file: \"#{path}\""
        file = File.new("../../" + path, "rb")
        bytes = file.read
        file.close
        puts "file=/#{bytes}/"
        #@basex.add(path, "#{bytes}")
        @basex.execute("check #{dbname}")
        fileUri = @basex.execute("xquery for $doc in db:open('#{dbname}', '#{path}') return document-uri($doc)")
        if fileUri != ""
           puts "File exists in database, deleting..."
           @basex.execute("delete \"#{path}\"")
           puts "#{@basex.info()}"
        end
        @basex.execute("add to \"#{path}\" \"#{bytes}\"")
     end
     
     # Do deletions:
     changes = `git diff #{@from} #{@to} --name-only --diff-filter=D`

     changes.split(/\n/).each do |path|
        puts "Deleted file: \"#{path}\""
        @basex.execute("delete \"#{path}\"")
        puts "#{@basex.info()}"
     end
  end
end

def getRepoName
  parts = `pwd`.split('/')
  repoName = parts[parts.length - 3]
end

puts "Running post-receive..."




STDIN.each do |line|
   puts "line=/#{line.chomp}/"
   from, to, branch, = line.chomp.split(/\s+/)

   puts "from=#{from}"
   puts "to=#{to}"
   puts "branch=#{branch}"
   updater = Updater.new(from, to, branch, getRepoName())
   updater.update()

end


puts "Post-receive done."